<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#000}
canvas{display:block}
#chat-container{position:fixed;bottom:20px;right:20px;width:300px;height:300px;background:rgba(0,0,0,0.5);color:white;display:flex;flex-direction:column;border-radius:8px;overflow:hidden;font-family:Arial,sans-serif;font-size:14px;z-index:1000}
#chat-header{padding:5px;text-align:center;font-weight:bold;display:flex;justify-content:space-between;align-items:center;}
#chat-messages{flex:1;padding:5px;display:flex;flex-direction:column-reverse;overflow-y:auto}
#chat-input{border:none;outline:none;padding:5px;width:100%;box-sizing:border-box;background:rgba(255,255,255,0.1);color:white}
#settings-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);display:none;justify-content:center;align-items:center;z-index:2000}
#settings-box{background:black;padding:20px;border-radius:10px;width:300px;display:flex;flex-direction:column;gap:10px;color:white;font-family:Arial,sans-serif;}
#username-input{padding:5px;border:none;outline:none;width:100%;}
#username-save{padding:5px;background:rgba(255,255,255,0.1);border:none;color:white;cursor:pointer;}
#settings-button{background:rgba(0,0,0,0.7);color:white;border:none;padding:2px 5px;border-radius:3px;cursor:pointer;}
</style>
</head>
<body>
<div id="chat-container">
  <div id="chat-header">
    Chat
    <button id="settings-button">⚙️</button>
  </div>
  <div id="chat-messages"></div>
  <input id="chat-input" type="text" placeholder="Type a message...">
</div>
<div id="settings-overlay">
  <div id="settings-box">
    <div>Username</div>
    <input id="username-input" type="text" placeholder="Enter username">
    <button id="username-save">Save</button>
  </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
<script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
<script>
const socket=io("https://649a82a8-3c73-46fd-a5a7-444c4aac2954-00-3epoxph1e9wys.spock.replit.dev")
function randomName(){let c='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',n='',l=Math.floor(Math.random()*(20-10+1)+10);for(let i=0;i<l;i++)n+=c.charAt(Math.floor(Math.random()*c.length));return n;}
let username=randomName()
const chatInput=document.getElementById("chat-input")
const chatMessages=document.getElementById("chat-messages")
const settingsButton=document.getElementById("settings-button")
const settingsOverlay=document.getElementById("settings-overlay")
const usernameInput=document.getElementById("username-input")
const usernameSave=document.getElementById("username-save")
settingsButton.addEventListener("click",()=>{settingsOverlay.style.display="flex";usernameInput.value=username})
usernameSave.addEventListener("click",()=>{if(usernameInput.value.trim()!==""){username=usernameInput.value.trim();settingsOverlay.style.display="none"}})
chatInput.addEventListener("keydown",e=>{if(e.key==="Enter"&&chatInput.value.trim()!==""){socket.emit("chatMessage",{username,message:chatInput.value.trim()});chatInput.value=""}})
socket.on("chatMessage",data=>{const d=document.createElement("div");d.textContent=`${data.username}: ${data.message}`;chatMessages.prepend(d)})
const scene=new THREE.Scene()
const loader=new THREE.TextureLoader()
const skyGeo=new THREE.SphereGeometry(1000,32,32)
const skyMat=new THREE.MeshBasicMaterial({map:loader.load('Sky/Vaporwave.png'),side:THREE.BackSide})
const sky=new THREE.Mesh(skyGeo,skyMat)
scene.add(sky)
const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,2000)
const renderer=new THREE.WebGLRenderer({antialias:true})
renderer.setSize(innerWidth,innerHeight)
document.body.appendChild(renderer.domElement)
window.onresize=()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight)}
scene.add(new THREE.AmbientLight(0xffffff,0.8))
const light=new THREE.DirectionalLight(0xffffff,1)
light.position.set(10,20,10)
scene.add(light)
const listener=new THREE.AudioListener()
camera.add(listener)
const sound=new THREE.Audio(listener)
new THREE.AudioLoader().load('Audio/Vaporwave.mp3',buffer=>{sound.setBuffer(buffer);sound.setLoop(true);sound.setVolume(0.5);sound.play()})
let blocks=[]
const blockSize=5
const colors=[0xff4dcc,0x0d0d0d]
function createBlock(pos,colorIndex=0,resources=10000){
const geo=new THREE.BoxGeometry(blockSize,blockSize,blockSize)
const mat=new THREE.MeshStandardMaterial({color:colors[colorIndex]})
const mesh=new THREE.Mesh(geo,mat)
mesh.scale.set(0.01,0.01,0.01)
mesh.position.copy(pos)
mesh.rotation.set((Math.random()-0.5)*0.2,(Math.random()-0.5)*0.2,(Math.random()-0.5)*0.2)
mesh.userData={colorIndex,resources}
scene.add(mesh)
blocks.push(mesh)
new TWEEN.Tween(mesh.scale).to({x:1,y:1,z:1},2000).start()
return mesh
}
createBlock(new THREE.Vector3(0,blockSize/2,0))
function attemptSpawn(block){
if(block.userData.resources<blockSize)return
const vectors=[new THREE.Vector3(-1,0,0),new THREE.Vector3(1,0,0),new THREE.Vector3(0,0,-1),new THREE.Vector3(0,0,1)]
const offset=Math.floor(Math.random()*vectors.length)
for(let i=0;i<vectors.length;i++){
const v=vectors[(i+offset)%vectors.length]
const newPos=block.position.clone().add(v.clone().multiplyScalar(blockSize))
if(blocks.some(b=>b.position.distanceTo(newPos)<blockSize*0.9))continue
const newBlock=createBlock(newPos,(block.userData.colorIndex+1)%2,block.userData.resources/2)
block.userData.resources/=2
socket.emit("spawnBlock",{position:newPos,colorIndex:(block.userData.colorIndex+1)%2,resources:block.userData.resources})
break
}}
socket.on("allBlocks",data=>{for(const b of data){createBlock(new THREE.Vector3(b.position.x,b.position.y,b.position.z),b.colorIndex,b.resources)}})
socket.on("blockSpawned",data=>{createBlock(new THREE.Vector3(data.position.x,data.position.y,data.position.z),data.colorIndex,data.resources)})
const player=new THREE.Group()
const torso=new THREE.Mesh(new THREE.BoxGeometry(2,2,1),new THREE.MeshStandardMaterial({color:0x00ff00}))
torso.position.y=1
player.add(torso)
const head=new THREE.Mesh(new THREE.BoxGeometry(1,1,1),new THREE.MeshStandardMaterial({color:0xcccccc}))
head.position.y=2.5
player.add(head)
const armGeo=new THREE.BoxGeometry(1,2,1)
const armL=new THREE.Mesh(armGeo,torso.material);armL.position.set(-1.5,1,0);player.add(armL)
const armR=new THREE.Mesh(armGeo,torso.material);armR.position.set(1.5,1,0);player.add(armR)
const legGeo=new THREE.BoxGeometry(1,2,1)
const legL=new THREE.Mesh(legGeo,torso.material);legL.position.set(-0.5,-1,0);player.add(legL)
const legR=new THREE.Mesh(legGeo,torso.material);legR.position.set(0.5,-1,0);player.add(legR)
player.position.y=5
scene.add(player)
const otherPlayers={}
const keys={}
addEventListener("keydown",e=>keys[e.code]=true)
addEventListener("keyup",e=>keys[e.code]=false)
let velY=0,gravity=-0.04,jump=0.8,speed=0.22,yaw=0,pitch=0,rotating=false,dead=false,respawnTimer=0,minZoom=2,maxZoom=50,currentZoom=10,targetZoom=10,shiftLock=false
const sensitivity=0.003
renderer.domElement.addEventListener("contextmenu",e=>e.preventDefault())
renderer.domElement.addEventListener("mousedown",e=>{if(e.button===2)rotating=true})
renderer.domElement.addEventListener("mouseup",e=>{if(e.button===2)rotating=false})
addEventListener("mousemove",e=>{if(rotating||shiftLock){yaw+=e.movementX*sensitivity*2;pitch-=e.movementY*sensitivity*2;pitch=Math.max(-Math.PI/2+0.2,Math.min(Math.PI/2-0.2,pitch))}})
addEventListener("wheel",e=>{const zoomDelta=(e.deltaY>0?1:-1)*6;targetZoom+=zoomDelta;if(targetZoom<minZoom)targetZoom=minZoom;if(targetZoom>maxZoom)targetZoom=maxZoom})
addEventListener("keydown",e=>{if(e.code==="ShiftLeft"){shiftLock=!shiftLock;if(shiftLock){document.body.requestPointerLock()}else{document.exitPointerLock()}}})
socket.on("allPlayers",data=>{for(const id in data){if(id!==socket.id&&!otherPlayers[id]){const g=new THREE.Group();const t=new THREE.Mesh(new THREE.BoxGeometry(2,2,1),new THREE.MeshStandardMaterial({color:0xff0000}));t.position.y=1;g.add(t);const h=new THREE.Mesh(new THREE.BoxGeometry(1,1,1),new THREE.MeshStandardMaterial({color:0xcccccc}));h.position.y=2.5;g.add(h);scene.add(g);otherPlayers[id]=g}}})
socket.on("playerMoved",data=>{if(!otherPlayers[data.id]){const g=new THREE.Group();const t=new THREE.Mesh(new THREE.BoxGeometry(2,2,1),new THREE.MeshStandardMaterial({color:0xff0000}));t.position.y=1;g.add(t);const h=new THREE.Mesh(new THREE.BoxGeometry(1,1,1),new THREE.MeshStandardMaterial({color:0xcccccc}));h.position.y=2.5;g.add(h);scene.add(g);otherPlayers[data.id]=g}otherPlayers[data.id].position.set(data.pos.x,data.pos.y,data.pos.z);otherPlayers[data.id].rotation.y=data.rotY})
socket.on("playerLeft",id=>{if(otherPlayers[id]){scene.remove(otherPlayers[id]);delete otherPlayers[id]}})
function respawn(){player.position.set(0,5,0);velY=0;dead=false;player.visible=true}
function update(){
currentZoom+=(targetZoom-currentZoom)*0.1
if(dead){respawnTimer-=1/60;if(respawnTimer<=0)respawn();return}
const forward=new THREE.Vector3(Math.sin(yaw),0,-Math.cos(yaw))
const right=new THREE.Vector3(Math.cos(yaw),0,Math.sin(yaw))
let move=new THREE.Vector3()
if(keys.KeyW)move.sub(forward)
if(keys.KeyS)move.add(forward)
if(keys.KeyA)move.add(right)
if(keys.KeyD)move.sub(right)
const isWalking=move.length()>0
if(isWalking){move.normalize().multiplyScalar(speed);player.position.add(move);const targetRot=Math.atan2(move.x,move.z);let diff=(targetRot-player.rotation.y+Math.PI*3)%(Math.PI*2)-Math.PI;player.rotation.y+=diff*0.2}
velY+=gravity
player.position.y+=velY
let onGround=false
for(const b of blocks){const px=player.position.x,py=player.position.y,pz=player.position.z,bx=b.position.x,by=b.position.y,bz=b.position.z,hw=blockSize/2,hl=blockSize/2;if(px+0.9>bx-hw&&px-0.9<bx+hw&&pz+0.9>bz-hl&&pz-0.9<bz+hl&&py>=by&&py<=by+blockSize){player.position.y=by+blockSize;velY=0;onGround=true}}
if(keys.Space&&onGround){velY=jump}
for(const b of blocks)attemptSpawn(b)
socket.emit("move",{x:player.position.x,y:player.position.y,z:player.position.z,rotY:player.rotation.y})
if(player.position.y<-150&&!dead){dead=true;respawnTimer=5;player.visible=false}
const t=performance.now()*0.003
if(isWalking&&onGround){legL.rotation.x=Math.sin(t)*0.3;legR.rotation.x=Math.sin(t+Math.PI)*0.3;armL.rotation.x=Math.sin(t+Math.PI)*0.25;armR.rotation.x=Math.sin(t)*0.25}else{legL.rotation.x=0;legR.rotation.x=0;if(onGround){armL.rotation.x=-Math.PI;armR.rotation.x=-Math.PI}}
if(!onGround){armL.rotation.x+=(Math.PI-armL.rotation.x)*0.08;armR.rotation.x+=(Math.PI-armR.rotation.x)*0.08;armL.position.y+=((3)-armL.position.y)*0.08;armR.position.y+=((3)-armR.position.y)*0.08}else{armL.position.y+=((1)-armL.position.y)*0.08;armR.position.y+=((1)-armR.position.y)*0.08;armL.rotation.x+=(-Math.PI-armL.rotation.x)*0.08;armR.rotation.x+=(-Math.PI-armR.rotation.x)*0.08}
const headPos=player.position.clone().add(new THREE.Vector3(0,2.5,0))
const dir=new THREE.Vector3(Math.sin(yaw)*Math.cos(pitch),Math.sin(pitch),-Math.cos(yaw)*Math.cos(pitch)).normalize()
camera.position.copy(headPos.clone().add(dir.clone().multiplyScalar(currentZoom)))
camera.lookAt(headPos)
TWEEN.update()
}
function loop(){update();renderer.render(scene,camera);requestAnimationFrame(loop)}
loop()
</script>
</body>
</html>
