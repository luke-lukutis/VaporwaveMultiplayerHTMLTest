<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#000}
canvas{display:block}
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
<script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
<script>
const socket=io("https://649a82a8-3c73-46fd-a5a7-444c4aac2954-00-3epoxph1e9wys.spock.replit.dev")
const scene=new THREE.Scene()
const loader=new THREE.TextureLoader()
const skyGeo=new THREE.SphereGeometry(1000,32,32)
const skyMat=new THREE.MeshBasicMaterial({map:loader.load('Sky/Vaporwave.png'),side:THREE.BackSide})
const sky=new THREE.Mesh(skyGeo,skyMat)
scene.add(sky)
const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,2000)
const renderer=new THREE.WebGLRenderer({antialias:true})
renderer.setSize(innerWidth,innerHeight)
document.body.appendChild(renderer.domElement)
onresize=()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight)}
scene.add(new THREE.AmbientLight(0xffffff,0.8))
const light=new THREE.DirectionalLight(0xffffff,1)
light.position.set(10,20,10)
scene.add(light)
const listener=new THREE.AudioListener()
camera.add(listener)
const sound=new THREE.Audio(listener)
new THREE.AudioLoader().load('Audio/Vaporwave.mp3',buffer=>{sound.setBuffer(buffer);sound.setLoop(true);sound.setVolume(0.5);sound.play()})
let blocks=[]
const blockSize=5
const colors=[0xff4dcc,0x0d0d0d]
function createBlock(pos,colorIndex=0,resources=10000){
const geo=new THREE.BoxGeometry(blockSize,blockSize,blockSize)
const mat=new THREE.MeshStandardMaterial({color:colors[colorIndex]})
const mesh=new THREE.Mesh(geo,mat)
mesh.scale.set(0.01,0.01,0.01)
mesh.position.copy(pos)
mesh.rotation.set((Math.random()-0.5)*0.2,(Math.random()-0.5)*0.2,(Math.random()-0.5)*0.2)
mesh.userData={colorIndex,resources}
scene.add(mesh)
blocks.push(mesh)
new TWEEN.Tween(mesh.scale).to({x:1,y:1,z:1},2000).start()
return mesh
}
createBlock(new THREE.Vector3(0,blockSize/2,0))
function createPlayerAvatar(color=0xaaaaaa){
const group=new THREE.Group()
const torso=new THREE.Mesh(new THREE.BoxGeometry(2,2,1),new THREE.MeshStandardMaterial({color:color}))
torso.position.y=1
group.add(torso)
const head=new THREE.Mesh(new THREE.BoxGeometry(1,1,1),new THREE.MeshStandardMaterial({color:0xcccccc}))
head.position.y=2.5
group.add(head)
const armGeo=new THREE.BoxGeometry(1,2,1)
const armL=new THREE.Mesh(armGeo,torso.material)
armL.position.set(-1.5,1,0)
group.add(armL)
const armR=new THREE.Mesh(armGeo,torso.material)
armR.position.set(1.5,1,0)
group.add(armR)
const legGeo=new THREE.BoxGeometry(1,2,1)
const legL=new THREE.Mesh(legGeo,torso.material)
legL.position.set(-0.5,-1,0)
group.add(legL)
const legR=new THREE.Mesh(legGeo,torso.material)
legR.position.set(0.5,-1,0)
group.add(legR)
group.userData={torso,head,armL,armR,legL,legR}
return group
}
const player=createPlayerAvatar(0xaaaaaa)
player.position.y=5
scene.add(player)
const otherPlayers={}
function createRemotePlayer(data){
const avatar=createPlayerAvatar(Math.random()*0xffffff)
avatar.position.set(data.x,data.y,data.z)
avatar.rotation.y=data.yaw
scene.add(avatar)
return avatar
}
const keys={}
addEventListener("keydown",e=>keys[e.code]=true)
addEventListener("keyup",e=>keys[e.code]=false)
let velY=0,gravity=-0.04,jump=0.8,speed=0.22
let yaw=0,pitch=0,rotating=false,dead=false,respawnTimer=0

let avatarYaw=0

let minZoom=2,maxZoom=50,currentZoom=10,targetZoom=10,shiftLock=false
const sensitivity=0.003
renderer.domElement.addEventListener("contextmenu",e=>e.preventDefault())
renderer.domElement.addEventListener("mousedown",e=>{if(e.button===2)rotating=true})
renderer.domElement.addEventListener("mouseup",e=>{if(e.button===2)rotating=false})
addEventListener("mousemove",e=>{
if(rotating||shiftLock){
yaw+=e.movementX*sensitivity*2
pitch-=e.movementY*sensitivity*2
pitch=Math.max(-Math.PI/2+0.2,Math.min(Math.PI/2-0.2,pitch))
}})
addEventListener("wheel",e=>{
const zoomDelta=(e.deltaY>0?1:-1)*6
targetZoom+=zoomDelta
if(targetZoom<minZoom)targetZoom=minZoom
if(targetZoom>maxZoom)targetZoom=maxZoom
})
addEventListener("keydown",e=>{
if(e.code==="ShiftLeft"){
shiftLock=!shiftLock
if(shiftLock){document.body.requestPointerLock()}else{document.exitPointerLock()}
}})
function attemptSpawn(block){
if(block.userData.resources<blockSize)return
const vectors=[new THREE.Vector3(-1,0,0),new THREE.Vector3(1,0,0),new THREE.Vector3(0,0,-1),new THREE.Vector3(0,0,1)]
const offset=Math.floor(Math.random()*vectors.length)
for(let i=0;i<vectors.length;i++){
const v=vectors[(i+offset)%vectors.length]
const newPos=block.position.clone().add(v.clone().multiplyScalar(blockSize))
if(blocks.some(b=>b.position.distanceTo(newPos)<blockSize*0.9))continue
const newBlock=createBlock(newPos,(block.userData.colorIndex+1)%2,block.userData.resources/2)
block.userData.resources/=2
break
}}
function respawn(){player.position.set(0,5,0);velY=0;dead=false;player.visible=true}
function update(){
currentZoom+=(targetZoom-currentZoom)*0.1
if(dead){respawnTimer-=1/60;if(respawnTimer<=0)respawn();return}
const forward=new THREE.Vector3(Math.sin(yaw),0,-Math.cos(yaw))
const right=new THREE.Vector3(Math.cos(yaw),0,Math.sin(yaw))
let move=new THREE.Vector3()
if(keys.KeyW)move.sub(forward)
if(keys.KeyS)move.add(forward)
if(keys.KeyA)move.add(right)
if(keys.KeyD)move.sub(right)
const isWalking=move.length()>0
if(isWalking){
move.normalize().multiplyScalar(speed)
player.position.add(move)
const targetRot=Math.atan2(move.x,move.z)
let diff=(targetRot-player.rotation.y+Math.PI*3)%(Math.PI*2)-Math.PI
player.rotation.y+=diff*0.2
avatarYaw=player.rotation.y
}
if(shiftLock)avatarYaw=yaw

velY+=gravity
player.position.y+=velY
let onGround=false
for(const b of blocks){
const px=player.position.x,py=player.position.y,pz=player.position.z
const bx=b.position.x,by=b.position.y,bz=b.position.z
const hw=blockSize/2,hl=blockSize/2
if(px+0.9>bx-hw&&px-0.9<bx+hw&&pz+0.9>bz-hl&&pz-0.9<bz+hl&&py>=by&&py<=by+blockSize){
player.position.y=by+blockSize
velY=0
onGround=true
}}
if(keys.Space&&onGround){velY=jump}
const t=performance.now()*0.003
if(isWalking&&onGround){
player.userData.legL.rotation.x=Math.sin(t)*0.3
player.userData.legR.rotation.x=Math.sin(t+Math.PI)*0.3
player.userData.armL.rotation.x=Math.sin(t+Math.PI)*0.25
player.userData.armR.rotation.x=Math.sin(t)*0.25
}else{
player.userData.legL.rotation.x=0
player.userData.legR.rotation.x=0
if(onGround){player.userData.armL.rotation.x=-Math.PI;player.userData.armR.rotation.x=-Math.PI}
}
if(!onGround){
player.userData.armL.rotation.x+=(Math.PI-player.userData.armL.rotation.x)*0.08
player.userData.armR.rotation.x+=(Math.PI-player.userData.armR.rotation.x)*0.08
player.userData.armL.position.y+=((3)-player.userData.armL.position.y)*0.08
player.userData.armR.position.y+=((3)-player.userData.armR.position.y)*0.08
}else{
player.userData.armL.position.y+=((1)-player.userData.armL.position.y)*0.08
player.userData.armR.position.y+=((1)-player.userData.armR.position.y)*0.08
player.userData.armL.rotation.x+=(-Math.PI-player.userData.armL.rotation.x)*0.08
player.userData.armR.rotation.x+=(-Math.PI-player.userData.armR.rotation.x)*0.08
}
const headPos=player.position.clone().add(new THREE.Vector3(0,2.5,0))
const dir=new THREE.Vector3(Math.sin(yaw)*Math.cos(pitch),Math.sin(pitch),-Math.cos(yaw)*Math.cos(pitch)).normalize()
camera.position.copy(headPos.clone().add(dir.clone().multiplyScalar(currentZoom)))
camera.lookAt(headPos)
for(const b of blocks)attemptSpawn(b)
if(player.position.y<-150&&!dead){dead=true;respawnTimer=5;player.visible=false}
TWEEN.update()

socket.emit("move",{
x:player.position.x,
y:player.position.y,
z:player.position.z,
yaw:avatarYaw,
walk:isWalking,
ground:onGround,
t
})

}
socket.on("allPlayers",data=>{
for(const id in data){
if(id===socket.id)continue
if(!otherPlayers[id])otherPlayers[id]=createRemotePlayer(data[id])
}})
socket.on("playerMoved",({id,pos})=>{
if(id===socket.id)return
if(!otherPlayers[id])otherPlayers[id]=createRemotePlayer(pos)
else{
const p=otherPlayers[id]
p.position.set(pos.x,pos.y,pos.z)
p.rotation.y=pos.yaw
if(pos.walk&&pos.ground){
p.userData.legL.rotation.x=Math.sin(pos.t)*0.3
p.userData.legR.rotation.x=Math.sin(pos.t+Math.PI)*0.3
p.userData.armL.rotation.x=Math.sin(pos.t+Math.PI)*0.25
p.userData.armR.rotation.x=Math.sin(pos.t)*0.25
}
}})
socket.on("playerLeft",id=>{
if(otherPlayers[id]){scene.remove(otherPlayers[id]);delete otherPlayers[id]}})
function loop(){update();renderer.render(scene,camera);requestAnimationFrame(loop)}
loop()
</script>
</body>
</html>
